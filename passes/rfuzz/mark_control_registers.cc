/*
 *  yosys -- Yosys Open SYnthesis Suite
 *
 *  Copyright (C) 2022  Tobias Kovats <tkovats@student.ethz.ch> & Flavien Solt <flsolt@ethz.ch>
 *
 *  Permission to use, copy, modify, and/or distribute this software for any
 *  purpose with or without fee is hereby granted, provided that the above
 *  copyright notice and this permission notice appear in all copies.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *
 *  This pass identifies multiplexers and backtracks to registers as described in the DifuzzRTL paper.
 *  As explained by the authors, we only cover registers and multiplexers in the exact same module, and whose wires never leave the module.
 *  Strategy: Iteratively, and until no new wire is discovered, do the following:
 *      - Initially, all and only mux select signals are marked.
 *      - Iterate through all cells. If a cell produces one of the newly marked wires, (a) if it is a register, then mark it as control register, (b) else mark all of not-yet marked input wires as newly marked.
 */

#include "kernel/log.h"
#include "kernel/register.h"
#include "kernel/rtlil.h"
#include "kernel/sigtools.h"
#include "kernel/utils.h"
#include "kernel/yosys.h"

#include <algorithm>
#include <unordered_set>

USING_YOSYS_NAMESPACE
PRIVATE_NAMESPACE_BEGIN

#define MAX_REGSTATE_BITS 20

struct MarkControlRegistersWorker {
private:
	// Command line arguments.
	bool opt_verbose;
	SigMap sigmap;
	RTLIL::Module *module;

	void mark_control_registers()
	{
		if (opt_verbose)
			log("Marking control registers in module %s.\n", module->name.c_str());

		if (module->processes.size())
			log("Multiplexers generated by process are ignored! Execute 'proc' pass to include them.\n");

		// This vector collects the control registers
		std::vector<RTLIL::Cell*> resulting_control_registers;

		////////////////////////
		// Part 1: Find the control registers
		////////////////////////

		// Pre-process a dict[wire] = cell, where wire is one output of the cell. We use a SigSpec to use the sigmap helper.
		dict<RTLIL::SigSpec, std::vector<RTLIL::Cell*>> wires_to_driver_cells;
		for (auto &cell_pair : module->cells_) {
			RTLIL::IdString cell_name = cell_pair.first;
			RTLIL::Cell *cell = cell_pair.second;

			// Ignore submodules here
			if (module->design->module(cell->type) != nullptr)
				continue;

			for (auto &port_it : cell->connections()) {
				RTLIL::SigSpec cell_sigspec = port_it.second;

				// Add the pair (wire, cell) to the index if it is not yet present.
				if (cell->output(port_it.first)) {
					for (auto &chunk_it : port_it.second.chunks()) {
						if (!chunk_it.is_wire())
							continue;
						if (wires_to_driver_cells.find(sigmap(chunk_it.wire)) == wires_to_driver_cells.end())
							wires_to_driver_cells[sigmap(chunk_it.wire)] = std::vector<RTLIL::Cell*>();
						if (std::find(wires_to_driver_cells[sigmap(chunk_it.wire)].begin(), wires_to_driver_cells[sigmap(chunk_it.wire)].end(), cell) == wires_to_driver_cells[sigmap(chunk_it.wire)].end())
							wires_to_driver_cells[sigmap(chunk_it.wire)].push_back(cell);
					}
				}
			}
		}

		log("	Preprocessing complete in module %s.\n", module->name.c_str());

		std::vector<RTLIL::Wire*> newly_marked_wires;
		std::unordered_set<RTLIL::Wire*> already_marked_wires;

		for (std::pair<RTLIL::IdString, RTLIL::Cell *> cell_pair_it : module->cells_) {
			RTLIL::IdString cell_name = cell_pair_it.first;
			RTLIL::Cell *cell = cell_pair_it.second;

            // Initial step: mark all mux select signals
			if (cell->type.in(ID($mux), ID($_MUX_), ID($_NMUX_))) { // checks if the cell is a mux
				RTLIL::SigSpec port_q(cell->getPort(ID::S));

				for (auto &chunk_it : port_q.chunks()) {

					if (!chunk_it.is_wire())
						continue; // skip constants

                    int is_already_present = 0;
                    for (auto &marked_wire_it : already_marked_wires) {
                        if (sigmap(marked_wire_it) == sigmap(chunk_it.wire)) {
                            is_already_present = 1;
                            break;
                        }
                    }

                    if (!is_already_present) {
                        already_marked_wires.insert(chunk_it.wire);
                        newly_marked_wires.push_back(chunk_it.wire);
                    }
                    n_mux++;
				}
			}
		}

		// Iterative step: until there are no new wires to explore, do the following:
		// - Find all the cells that output a newly marked wire, and mark their inputs as newly marked wires.
		std::vector<RTLIL::Wire*> previously_newly_marked_wires;
		// Remember all wires already marked in the past
		std::unordered_set<RTLIL::Cell*> already_marked_cells; // This is just for speedup
		do {
			// Add all the wires that were newly marked in the previous iteration to the set of already marked wires
			for (auto &wire_it: newly_marked_wires)
				already_marked_wires.insert(wire_it);

			// The new wires become the previously new wires
			previously_newly_marked_wires.swap(newly_marked_wires);
			newly_marked_wires.clear();

			for (auto &prev_wire_it : previously_newly_marked_wires) {

				// Iterate through all cells that drive this previously marked wire
				for (RTLIL::Cell *cell : wires_to_driver_cells[sigmap(prev_wire_it)]) {
					// No need to explore multiple times the same cell if its inputs have all been marked already.
					if (already_marked_cells.find(cell) != already_marked_cells.end())
						continue;
					already_marked_cells.insert(cell);

					// Discriminate between combinational and sequential cells
					if (cell->type.in(ID($dlatch), ID($_DLATCH_N_), ID($_DLATCH_P_), ID($dff), ID($_DFF_NN0_), ID($_DFF_NN1_), ID($_DFF_NP0_), ID($_DFF_NP1_), ID($_DFF_PN0_), ID($_DFF_PN1_), ID($_DFF_PP0_), ID($_DFF_PP0_), ID($adff), ID($aldff), ID($sdff), ID($_SDFF_NN0_), ID($_SDFF_NN1_), ID($_SDFF_NP0_), ID($_SDFF_NP1_), ID($_SDFF_PN0_), ID($_SDFF_PN1_), ID($_SDFF_PP0_), ID($_SDFF_PP1_), ID($adffe), ID($sdffe), ID($dffe), ID($_DFFE_NN_), ID($_DFFE_NP_), ID($_DFFE_PN_), ID($_DFFE_PP_), ID($sdffce), ID($_SDFFCE_NN0N_), ID($_SDFFCE_NN0P_), ID($_SDFFCE_NN1N_), ID($_SDFFCE_NN1P_), ID($_SDFFCE_NP0N_), ID($_SDFFCE_NP0P_), ID($_SDFFCE_NP1N_), ID($_SDFFCE_NP1P_), ID($_SDFFCE_PN0N_), ID($_SDFFCE_PN0P_), ID($_SDFFCE_PN1N_), ID($_SDFFCE_PN1P_), ID($_SDFFCE_PP0N_), ID($_SDFFCE_PP0P_), ID($_SDFFCE_PP1N_), ID($_SDFFCE_PP1P_), ID($_SDFFE_NN0N_), ID($_SDFFE_NN0P_), ID($_SDFFE_NN1N_), ID($_SDFFE_NN1P_), ID($_SDFFE_NP0N_), ID($_SDFFE_NP0P_), ID($_SDFFE_NP1N_), ID($_SDFFE_NP1P_), ID($_SDFFE_PN0N_), ID($_SDFFE_PN0P_), ID($_SDFFE_PN1N_), ID($_SDFFE_PN1P_), ID($_SDFFE_PP0N_), ID($_SDFFE_PP0P_), ID($_SDFFE_PP1N_), ID($_SDFFE_PP1P_), ID($_DFFE_NN0N_), ID($_DFFE_NN0P_), ID($_DFFE_NN1N_), ID($_DFFE_NN1P_), ID($_DFFE_NP0N_), ID($_DFFE_NP0P_), ID($_DFFE_NP1N_), ID($_DFFE_NP1P_), ID($_DFFE_PN0N_), ID($_DFFE_PN0P_), ID($_DFFE_PN1N_), ID($_DFFE_PN1P_), ID($_DFFE_PP0N_), ID($_DFFE_PP0P_), ID($_DFFE_PP1N_), ID($_DFFE_PP1P_), ID($_SDFF_PN0_), ID($_SDFF_PN1_), ID($_SDFF_PP0_), ID($_DFF_N_), ID($_DFF_P_))) {
						// Assert that the cell is not yet present in the result vector
						log_assert(std::find(resulting_control_registers.begin(), resulting_control_registers.end(), cell) == resulting_control_registers.end());
						resulting_control_registers.push_back(cell);
						n_ctrl_regs++;
						if (opt_verbose)
							log("			Marking cell %s as control register.\n", cell->name.c_str());
						break;
					} else {
						// Iterate through all cell connections and for all input connections, mark as newly marked if applicable.
						for (auto &candidate_input_port_it : cell->connections()) {
							if (cell->input(candidate_input_port_it.first)) {
								for (auto &candidate_chunk_it : candidate_input_port_it.second.chunks()) {
									if (!candidate_chunk_it.is_wire())
										continue;
									if (already_marked_wires.find(candidate_chunk_it.wire) != already_marked_wires.end())
										continue;
									newly_marked_wires.push_back(candidate_chunk_it.wire);
									// log("			New wire for cell type %s: %s\n", cell->type.c_str(), candidate_chunk_it.wire->name.c_str());
								}
							}
						}
						// At this stage, we marked the inputs of the cell. No need to check whether more output wires were newly marked by the previous pass.
						break;
					}
				}
			}
		} while (newly_marked_wires.size() > 0);
		log("Marked %li control registers in module %s.\n", n_ctrl_regs, RTLIL::id2cstr(module->name));
		log_assert(resulting_control_registers.size() == n_ctrl_regs);

		////////////////////////
		// Part 2: Create regstate, covmap and covsum
		////////////////////////

		if (resulting_control_registers.size() == 0)
			return;

		// Define the max size of the control register state
		int max_coverage_state_size = 0;
		for (auto &cell_it : resulting_control_registers) {
			RTLIL::Cell *cell = cell_it;
			log_assert(cell->hasPort(ID::Q));
			RTLIL::SigSpec port_q(cell->getPort(ID::Q));
			max_coverage_state_size = std::max(max_coverage_state_size, GetSize(port_q));
		}
		int regstate_size = std::min(max_coverage_state_size, MAX_REGSTATE_BITS);

		// Create the regstate hash function
		std::vector<RTLIL::SigSpec> shifted_to_xor_vector;
		// Shifts by deterministic random offsets
		for (auto &cell : resulting_control_registers) {
			RTLIL::SigSpec port_q(cell->getPort(ID::Q));
			int shift_slack = std::max(0, regstate_size - GetSize(port_q));
			int shamt = 0;
			if (shift_slack > 0)
				shamt = random() % shift_slack;
			RTLIL::SigSpec port_q_shifted = module->Shl(NEW_ID, port_q, RTLIL::Const(shamt, regstate_size));
			shifted_to_xor_vector.push_back(port_q_shifted);
		}
		// XORs, could be done as a tree but let's be lazy for a second.
		RTLIL::SigSpec prev_xor_output = RTLIL::Const(0, regstate_size);
		for (auto &sigspec_to_xor : shifted_to_xor_vector) {
			prev_xor_output = module->Xor(NEW_ID, prev_xor_output, sigspec_to_xor).extract(0, regstate_size);
		}

		// Populate the regstate using this xor output.
		RTLIL::SigSpec regstate_q(module->addWire(NEW_ID, regstate_size));
		RTLIL::SigSpec clock_sigspec;
		if (resulting_control_registers[0]->hasPort(ID::CLK))
			clock_sigspec = resulting_control_registers[0]->getPort(ID::CLK);
		else
			clock_sigspec = resulting_control_registers[0]->getPort(ID::C);

		// log("For module %s, creating regstate of size %i.\n", module->name.c_str(), regstate_size);
		// log("    prev_xor_output size: %i\n", GetSize(prev_xor_output));
		// log("    regstate_q size: %i\n", GetSize(regstate_q));
		// log("    clock port: %s\n", clock_sigspec.as_string().c_str());
		// log("    clock port size: %i\n", GetSize(resulting_control_registers[0]->getPort(ID::CLK)));
		// log("    clock polarity: %i\n", resulting_control_registers[0]->getParam(ID(CLK_POLARITY)).as_bool());

		RTLIL::Cell* regstate_cell = module->addDff(NEW_ID, clock_sigspec, prev_xor_output, regstate_q, resulting_control_registers[0]->getParam(ID(CLK_POLARITY)).as_bool());
		regstate_cell->set_bool_attribute(ID(regstate_cell));

		// Do not implement the coverage map! That would be 1 million bits, impractical for our purposes.
	}

public:
	size_t n_ctrl_regs = 0;
	size_t n_mux = 0;

	MarkControlRegistersWorker(RTLIL::Module *module, bool opt_verbose)
	{
		this->opt_verbose = opt_verbose;
		this->module = module;
		this->sigmap = SigMap(module);
		mark_control_registers();
	}
};

struct MarkControlRegistersPass : public Pass {
	MarkControlRegistersPass() : Pass("mark_control_registers", "Mark control registers like DifuzzRTL does") {}

	void help() override
	{
		//   |---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|---v---|
		log("\n");
		log("    mark_control_registers <command> [options] [selection]\n");
		log("\n");
		log("Marks control registers like DifuzzRTL does.\n");
		log("\n");
		log("Options:\n");
		log("\n");
		log("  -verbose\n");
		log("    Verbose mode.\n");
	}

	void execute(std::vector<std::string> args, RTLIL::Design *design) override
	{
		bool opt_verbose = false;

		std::vector<std::string>::size_type argidx;
		for (argidx = 1; argidx < args.size(); argidx++) {
			if (args[argidx] == "-verbose") {
				opt_verbose = true;
				continue;
			}
		}

		log_header(design, "Executing mux_probes pass.\n");

		if (GetSize(design->selected_modules()) == 0) {
			log_cmd_error("Can't operate on an empty selection!\n");
		}

		if (design->top_module() == NULL) {
			log_cmd_error("Can't operate without top module selected! Run hierarchy -top [top_module]!\n");
		}

		// Modules must be taken in inverted topological order to instrument the deepest modules first.
		// Taken from passes/techmap/flatten.cc
		TopoSort<RTLIL::Module *, IdString::compare_ptr_by_name<RTLIL::Module>> topo_modules;
		auto worklist = design->selected_modules();
		while (!worklist.empty()) {
			RTLIL::Module *module = *(worklist.begin());
			worklist.erase(worklist.begin());
			topo_modules.node(module);

			for (auto cell : module->selected_cells()) {
				RTLIL::Module *tpl = design->module(cell->type);
				if (tpl != nullptr) {
					if (topo_modules.get_database().count(tpl) == 0)
						worklist.push_back(tpl);
					topo_modules.edge(tpl, module);
				}
			}
		}
		if (!topo_modules.sort())
			log_cmd_error("Recursive modules are not supported by mux_probes.\n");

		int total_count = 0;
		int total_ctrl_regs = 0;
		for (auto i = 0; i < GetSize(topo_modules.sorted); ++i) {
			RTLIL::Module *module = topo_modules.sorted[i];
			MarkControlRegistersWorker worker = MarkControlRegistersWorker(module, opt_verbose);
			total_count += worker.n_mux;
			total_ctrl_regs += worker.n_ctrl_regs;
		}
		log("Marked %i control registers in total.\n", total_ctrl_regs);
	}
} MarkControlRegistersPass;

PRIVATE_NAMESPACE_END
